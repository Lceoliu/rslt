"""
Skeleton Motion Visualization with Adjacency Matrix

This script visualizes skeleton motion from .npy files using the adjacency matrices
generated by the fixed gen_adjacency_matrix method.

Features:
- Load COCO-Wholebody format .npy files
- Visualize each body part separately
- Show skeleton connections from adjacency matrices
- Generate video with multi-part view
- Validate adjacency matrix correctness visually
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib

matplotlib.use('Agg')  # Non-interactive backend
from matplotlib.animation import FuncAnimation, FFMpegWriter
import argparse
import sys
from pathlib import Path
from typing import Dict, List, Tuple, Optional
from tqdm import tqdm

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent))

try:
    from dataset.transform import NormalizeProcessor
except ImportError:
    print("Error: Cannot import NormalizeProcessor")
    sys.exit(1)


class SkeletonMotionVisualizer:
    """Visualize skeleton motion using adjacency matrices"""

    def __init__(
        self,
        conf_threshold: float = 0.25,
        fps: int = 30,
        figsize: Tuple[int, int] = (20, 12),
        output_dir: str = "skeleton_visualizations",
    ):
        """
        Args:
            conf_threshold: Confidence threshold for keypoints
            fps: Frames per second for output video
            figsize: Figure size
            output_dir: Output directory for visualizations
        """
        self.conf_threshold = conf_threshold
        self.fps = fps
        self.figsize = figsize
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # Initialize processor
        self.processor = NormalizeProcessor(
            keypoint_format='COCO_Wholebody',
            conf_threshold=conf_threshold,
            add_fullbody_channel=True,
        )

        # Get adjacency matrices with edge information
        print("Generating adjacency matrices...")
        self.adj_dict = self.processor.gen_adjacency_matrix(
            normalize=False, split_part=True
        )

        # Extract edge lists from adjacency matrices
        self.edge_dict = self._extract_edges_from_adjacency()

        print(f"✓ Initialized with {len(self.edge_dict)} body parts")
        for part, edges in self.edge_dict.items():
            print(f"  - {part}: {len(edges)} edges")

    def _extract_edges_from_adjacency(self) -> Dict[str, List[Tuple[int, int]]]:
        """Extract edge lists from adjacency matrices

        Returns:
            Dictionary mapping part names to lists of (i, j) edge tuples
        """
        edge_dict = {}

        for part, adj_matrix in self.adj_dict.items():
            edges = []
            n = adj_matrix.shape[0]

            # Extract edges (avoid duplicates by only taking upper triangle)
            for i in range(n):
                for j in range(i + 1, n):
                    if adj_matrix[i, j] > 0:
                        edges.append((i, j))

            edge_dict[part] = edges

        return edge_dict

    def load_npy_file(self, npy_path: str) -> np.ndarray:
        """Load .npy file in COCO-Wholebody format

        Args:
            npy_path: Path to .npy file

        Returns:
            Keypoints array of shape (T, 134, 3)
        """
        keypoints = np.load(npy_path)

        if keypoints.ndim != 3:
            raise ValueError(f"Expected 3D array, got shape {keypoints.shape}")

        if keypoints.shape[1] != 134:
            raise ValueError(
                f"Expected 134 keypoints (COCO-Wholebody + size marker), "
                f"got {keypoints.shape[1]}"
            )

        if keypoints.shape[2] != 3:
            raise ValueError(
                f"Expected 3 channels (x,y,conf), got {keypoints.shape[2]}"
            )

        print(f"✓ Loaded keypoints: shape={keypoints.shape}")
        return keypoints

    def process_keypoints(self, keypoints: np.ndarray) -> Dict[str, np.ndarray]:
        """Process keypoints through NormalizeProcessor pipeline

        Args:
            keypoints: Raw keypoints (T, 134, 3)

        Returns:
            Dictionary of processed keypoints by part
        """
        print("Processing keypoints through pipeline...")

        # Process through the pipeline (normalization, splitting, etc.)
        processed_parts = self.processor(
            keypoints,
            concat_velocity=False,
            concat_acceleration=False,
            generate_video=False,
        )

        print("✓ Keypoints processed")
        for part, kpts in processed_parts.items():
            print(f"  - {part}: {kpts.shape}")

        return processed_parts

    def _compute_bbox(self, keypoints: np.ndarray) -> Tuple[float, float, float, float]:
        """Compute bounding box for keypoints

        Args:
            keypoints: Keypoints array (T, K, C) or (K, C)

        Returns:
            (x_min, y_min, x_max, y_max)
        """
        if keypoints.ndim == 3:
            # (T, K, C)
            x = keypoints[..., 0]
            y = keypoints[..., 1]
            conf = keypoints[..., 2]
        else:
            # (K, C)
            x = keypoints[:, 0]
            y = keypoints[:, 1]
            conf = keypoints[:, 2]

        # Only consider points with confidence > threshold
        valid = conf > self.conf_threshold

        if not np.any(valid):
            return 0, 0, 1, 1

        x_valid = x[valid]
        y_valid = y[valid]

        x_min, x_max = np.min(x_valid), np.max(x_valid)
        y_min, y_max = np.min(y_valid), np.max(y_valid)

        # Add padding (10% of range)
        x_range = x_max - x_min
        y_range = y_max - y_min
        padding = max(x_range, y_range) * 0.1

        return x_min - padding, y_min - padding, x_max + padding, y_max + padding

    def visualize_frame(
        self,
        ax,
        keypoints: np.ndarray,
        edges: List[Tuple[int, int]],
        part_name: str,
        bbox: Optional[Tuple[float, float, float, float]] = None,
    ):
        """Visualize a single frame for one body part

        Args:
            ax: Matplotlib axis
            keypoints: Keypoints for this frame (K, 3)
            edges: List of edge tuples
            part_name: Name of body part
            bbox: Bounding box (x_min, y_min, x_max, y_max)
        """
        ax.clear()

        # Set axis limits
        if bbox is not None:
            x_min, y_min, x_max, y_max = bbox
            ax.set_xlim(x_min, x_max)
            ax.set_ylim(y_max, y_min)  # Invert y-axis

        # Plot keypoints
        x = keypoints[:, 0]
        y = keypoints[:, 1]
        conf = keypoints[:, 2]

        # Separate high and low confidence points
        high_conf_mask = conf > self.conf_threshold
        low_conf_mask = (conf > 0) & (conf <= self.conf_threshold)

        # Plot high confidence points
        if np.any(high_conf_mask):
            ax.scatter(
                x[high_conf_mask],
                y[high_conf_mask],
                c='blue',
                s=50,
                alpha=0.8,
                zorder=3,
                label='High confidence',
            )

        # Plot low confidence points
        if np.any(low_conf_mask):
            ax.scatter(
                x[low_conf_mask],
                y[low_conf_mask],
                c='gray',
                s=30,
                alpha=0.4,
                zorder=2,
                label='Low confidence',
            )

        # Plot edges (skeleton connections)
        for i, j in edges:
            if i < len(keypoints) and j < len(keypoints):
                # Check confidence of both endpoints
                conf_i = conf[i]
                conf_j = conf[j]
                avg_conf = (conf_i + conf_j) / 2

                if avg_conf > self.conf_threshold:
                    # High confidence edge - solid line
                    ax.plot(
                        [x[i], x[j]],
                        [y[i], y[j]],
                        'r-',
                        linewidth=2,
                        alpha=0.8,
                        zorder=1,
                    )
                elif avg_conf > 0:
                    # Low confidence edge - dashed line
                    ax.plot(
                        [x[i], x[j]],
                        [y[i], y[j]],
                        'b--',
                        linewidth=1,
                        alpha=0.3,
                        zorder=1,
                    )

        ax.set_title(f'{part_name}', fontsize=12, fontweight='bold')
        ax.set_xlabel('X')
        ax.set_ylabel('Y')
        ax.grid(True, alpha=0.3)
        ax.set_aspect('equal', adjustable='box')

    def create_multi_part_video(
        self,
        processed_parts: Dict[str, np.ndarray],
        output_path: str,
        parts_to_show: Optional[List[str]] = None,
    ):
        """Create video showing multiple body parts

        Args:
            processed_parts: Dictionary of processed keypoints by part
            output_path: Output video path
            parts_to_show: List of parts to visualize (default: all)
        """
        if parts_to_show is None:
            parts_to_show = ['body', 'face', 'left_hand', 'right_hand']

        # Filter to available parts
        parts_to_show = [p for p in parts_to_show if p in processed_parts]

        if not parts_to_show:
            raise ValueError("No valid parts to visualize")

        print(f"Creating multi-part video for: {parts_to_show}")

        # Get number of frames
        T = next(iter(processed_parts.values())).shape[0]

        # Compute bounding boxes
        bboxes = {
            part: self._compute_bbox(processed_parts[part]) for part in parts_to_show
        }

        # Setup figure
        n_parts = len(parts_to_show)
        cols = 2
        rows = (n_parts + 1) // 2

        fig, axes = plt.subplots(rows, cols, figsize=self.figsize)
        if n_parts == 1:
            axes = [axes]
        else:
            axes = axes.flatten()

        # Hide extra subplots
        for i in range(n_parts, len(axes)):
            axes[i].axis('off')

        fig.suptitle('Skeleton Motion Visualization', fontsize=16, fontweight='bold')

        # Animation function
        def update(frame):
            for i, part in enumerate(parts_to_show):
                keypoints = processed_parts[part][frame]
                edges = self.edge_dict[part]
                bbox = bboxes[part]

                self.visualize_frame(
                    axes[i], keypoints, edges, f"{part} (frame {frame}/{T})", bbox
                )

            return axes

        # Create animation
        print(f"Rendering {T} frames...")
        anim = FuncAnimation(
            fig,
            update,
            frames=tqdm(range(T), desc="Rendering"),
            blit=False,
            repeat=True,
        )

        # Save video
        writer = FFMpegWriter(fps=self.fps, bitrate=5000)
        anim.save(output_path, writer=writer)

        plt.close(fig)
        print(f"✓ Saved video: {output_path}")

    def create_comparison_video(
        self,
        raw_keypoints: np.ndarray,
        processed_parts: Dict[str, np.ndarray],
        output_path: str,
    ):
        """Create video comparing raw and processed keypoints

        Args:
            raw_keypoints: Raw keypoints (T, 134, 3)
            processed_parts: Processed keypoints by part
            output_path: Output video path
        """
        print("Creating comparison video...")

        T = raw_keypoints.shape[0]

        # Extract raw fullbody (remove size marker)
        raw_fullbody = raw_keypoints[:, 1:, :]  # (T, 133, 3)

        # Setup figure with 2 columns: raw vs processed
        fig, axes = plt.subplots(2, 2, figsize=(16, 12))

        fig.suptitle('Raw vs Processed Keypoints', fontsize=16, fontweight='bold')

        # Compute bounding boxes
        raw_bbox = self._compute_bbox(raw_fullbody)
        processed_bbox = self._compute_bbox(
            processed_parts.get('fullbody', processed_parts['body'])
        )

        # Get edges for fullbody
        fullbody_edges = self.edge_dict.get('fullbody', self.edge_dict['body'])

        def update(frame):
            # Top row: Raw keypoints
            # Left: all keypoints
            axes[0, 0].clear()
            x = raw_fullbody[frame, :, 0]
            y = raw_fullbody[frame, :, 1]
            conf = raw_fullbody[frame, :, 2]

            valid = conf > self.conf_threshold
            axes[0, 0].scatter(x[valid], y[valid], c='blue', s=30, alpha=0.6)
            axes[0, 0].scatter(x[~valid], y[~valid], c='gray', s=20, alpha=0.3)
            axes[0, 0].set_xlim(raw_bbox[0], raw_bbox[2])
            axes[0, 0].set_ylim(raw_bbox[3], raw_bbox[1])
            axes[0, 0].set_title(
                f'Raw Keypoints (frame {frame}/{T})', fontweight='bold'
            )
            axes[0, 0].grid(True, alpha=0.3)

            # Right: with skeleton
            axes[0, 1].clear()
            axes[0, 1].scatter(x[valid], y[valid], c='blue', s=30, alpha=0.6)

            # Draw connections from body_info edges (not from adjacency yet)
            for part_name, part_edges in self.processor.edges.items():
                for edge in part_edges:
                    i, j = edge
                    if i < 133 and j < 133:
                        if (
                            conf[i] > self.conf_threshold
                            and conf[j] > self.conf_threshold
                        ):
                            axes[0, 1].plot(
                                [x[i], x[j]],
                                [y[i], y[j]],
                                'r-',
                                linewidth=1.5,
                                alpha=0.6,
                            )

            axes[0, 1].set_xlim(raw_bbox[0], raw_bbox[2])
            axes[0, 1].set_ylim(raw_bbox[3], raw_bbox[1])
            axes[0, 1].set_title(
                f'Raw with Skeleton (frame {frame}/{T})', fontweight='bold'
            )
            axes[0, 1].grid(True, alpha=0.3)

            # Bottom row: Processed keypoints
            if 'fullbody' in processed_parts:
                processed = processed_parts['fullbody'][frame]
                part_edges = fullbody_edges
            else:
                processed = processed_parts['body'][frame]
                part_edges = self.edge_dict['body']

            # Left: processed keypoints only
            axes[1, 0].clear()
            x_proc = processed[:, 0]
            y_proc = processed[:, 1]
            conf_proc = processed[:, 2]

            valid_proc = conf_proc > self.conf_threshold
            axes[1, 0].scatter(
                x_proc[valid_proc], y_proc[valid_proc], c='green', s=30, alpha=0.6
            )
            axes[1, 0].scatter(
                x_proc[~valid_proc], y_proc[~valid_proc], c='gray', s=20, alpha=0.3
            )
            axes[1, 0].set_xlim(processed_bbox[0], processed_bbox[2])
            axes[1, 0].set_ylim(processed_bbox[3], processed_bbox[1])
            axes[1, 0].set_title(
                f'Processed Keypoints (frame {frame}/{T})', fontweight='bold'
            )
            axes[1, 0].grid(True, alpha=0.3)

            # Right: with skeleton from adjacency matrix
            axes[1, 1].clear()
            axes[1, 1].scatter(
                x_proc[valid_proc], y_proc[valid_proc], c='green', s=30, alpha=0.6
            )

            # Draw edges from adjacency matrix
            for i, j in part_edges:
                if i < len(x_proc) and j < len(x_proc):
                    avg_conf = (conf_proc[i] + conf_proc[j]) / 2
                    if avg_conf > self.conf_threshold:
                        axes[1, 1].plot(
                            [x_proc[i], x_proc[j]],
                            [y_proc[i], y_proc[j]],
                            'r-',
                            linewidth=2,
                            alpha=0.8,
                        )

            axes[1, 1].set_xlim(processed_bbox[0], processed_bbox[2])
            axes[1, 1].set_ylim(processed_bbox[3], processed_bbox[1])
            axes[1, 1].set_title(
                f'Processed with Adjacency Edges (frame {frame}/{T})', fontweight='bold'
            )
            axes[1, 1].grid(True, alpha=0.3)

            return axes.flatten()

        # Create animation
        anim = FuncAnimation(
            fig,
            update,
            frames=tqdm(range(T), desc="Rendering comparison"),
            blit=False,
            repeat=True,
        )

        # Save video
        writer = FFMpegWriter(fps=self.fps, bitrate=5000)
        anim.save(output_path, writer=writer)

        plt.close(fig)
        print(f"✓ Saved comparison video: {output_path}")

    def visualize_adjacency_on_skeleton(
        self,
        processed_parts: Dict[str, np.ndarray],
        output_path: str,
        frame_idx: int = 0,
    ):
        """Create static image showing adjacency matrix edges on skeleton

        Args:
            processed_parts: Processed keypoints by part
            output_path: Output image path
            frame_idx: Which frame to visualize
        """
        print(f"Creating adjacency visualization for frame {frame_idx}...")

        parts_to_show = ['body', 'left_hand', 'right_hand', 'face']
        parts_to_show = [p for p in parts_to_show if p in processed_parts]

        n_parts = len(parts_to_show)
        cols = 2
        rows = (n_parts + 1) // 2

        fig, axes = plt.subplots(rows, cols, figsize=(16, 12))
        if n_parts == 1:
            axes = [axes]
        else:
            axes = axes.flatten()

        fig.suptitle(
            f'Adjacency Matrix Connections on Skeleton (Frame {frame_idx})',
            fontsize=16,
            fontweight='bold',
        )

        for i, part in enumerate(parts_to_show):
            keypoints = processed_parts[part][frame_idx]
            edges = self.edge_dict[part]
            adj_matrix = self.adj_dict[part]

            bbox = self._compute_bbox(keypoints.reshape(1, -1, 3))

            self.visualize_frame(axes[i], keypoints, edges, part, bbox)

            # Add info text
            n_nodes = adj_matrix.shape[0]
            n_edges = len(edges)
            info_text = (
                f"Nodes: {n_nodes}\nEdges: {n_edges}\nAdj shape: {adj_matrix.shape}"
            )
            axes[i].text(
                0.02,
                0.98,
                info_text,
                transform=axes[i].transAxes,
                fontsize=9,
                verticalalignment='top',
                bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.7),
            )

        # Hide extra subplots
        for i in range(n_parts, len(axes)):
            axes[i].axis('off')

        plt.tight_layout()
        fig.savefig(output_path, dpi=150, bbox_inches='tight')
        plt.close(fig)

        print(f"✓ Saved adjacency visualization: {output_path}")

    def run_full_visualization(self, npy_path: str):
        """Run complete visualization pipeline

        Args:
            npy_path: Path to input .npy file
        """
        print("=" * 70)
        print("SKELETON MOTION VISUALIZATION")
        print("=" * 70)
        print()

        # Load data
        print(f"Loading: {npy_path}")
        raw_keypoints = self.load_npy_file(npy_path)
        print()

        # Process keypoints
        processed_parts = self.process_keypoints(raw_keypoints)
        print()

        # Get base name for outputs
        base_name = Path(npy_path).stem

        # 1. Multi-part video
        print("=" * 70)
        print("Creating multi-part video...")
        print("=" * 70)
        video_path = self.output_dir / f"{base_name}_multipart.mp4"
        self.create_multi_part_video(processed_parts, str(video_path))
        print()

        # 2. Comparison video
        print("=" * 70)
        print("Creating comparison video...")
        print("=" * 70)
        comparison_path = self.output_dir / f"{base_name}_comparison.mp4"
        self.create_comparison_video(
            raw_keypoints, processed_parts, str(comparison_path)
        )
        print()

        # 3. Static adjacency visualization
        print("=" * 70)
        print("Creating static adjacency visualization...")
        print("=" * 70)
        for frame_idx in [0, len(raw_keypoints) // 2, len(raw_keypoints) - 1]:
            adj_img_path = (
                self.output_dir / f"{base_name}_adjacency_frame{frame_idx:04d}.png"
            )
            self.visualize_adjacency_on_skeleton(
                processed_parts, str(adj_img_path), frame_idx=frame_idx
            )
        print()

        # Summary
        print("=" * 70)
        print("VISUALIZATION COMPLETE")
        print("=" * 70)
        print(f"Output directory: {self.output_dir.absolute()}")
        print(f"\nGenerated files:")
        for file in sorted(self.output_dir.glob(f"{base_name}*")):
            print(f"  - {file.name}")
        print("=" * 70)


def main():
    parser = argparse.ArgumentParser(
        description="Visualize skeleton motion from .npy file using adjacency matrices"
    )
    parser.add_argument(
        "npy_file",
        type=str,
        help="Path to .npy file (COCO-Wholebody format, shape: [T, 134, 3])",
    )
    parser.add_argument(
        "--conf-threshold",
        type=float,
        default=0.25,
        help="Confidence threshold for keypoints (default: 0.25)",
    )
    parser.add_argument(
        "--fps",
        type=int,
        default=30,
        help="Frames per second for output video (default: 30)",
    )
    parser.add_argument(
        "--output-dir",
        type=str,
        default="skeleton_visualizations",
        help="Output directory (default: skeleton_visualizations)",
    )

    args = parser.parse_args()

    # Check file exists
    if not Path(args.npy_file).exists():
        print(f"Error: File not found: {args.npy_file}")
        sys.exit(1)

    # Create visualizer
    visualizer = SkeletonMotionVisualizer(
        conf_threshold=args.conf_threshold, fps=args.fps, output_dir=args.output_dir
    )

    # Run visualization
    try:
        visualizer.run_full_visualization(args.npy_file)
    except Exception as e:
        print(f"\n❌ Error during visualization: {e}")
        import traceback

        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
